<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GE-S2DR3 — Minimal WebGIS Inference</title>
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <style>
    :root {
      --bg: #0b0f14;
      --panel: #111923;
      --muted: #9fb0c0;
      --text: #e6edf3;
      --accent: #7cc1ff;
      --danger: #ff6b6b;
      --ok: #7dffa7;
    }
    html, body { height: 100%; margin: 0; }
    body { display: grid; grid-template-columns: 340px 1fr; background: var(--bg); color: var(--text); font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #sidebar { padding: 16px; background: var(--panel); border-right: 1px solid #1d2935; overflow: auto; }
    #map { height: 100vh; }
    h1 { font-size: 16px; margin: 0 0 10px; letter-spacing: .2px; }
    .muted { color: var(--muted); }
    label { display: block; font-weight: 600; margin: 12px 0 6px; }
    input[type="text"], textarea, select { width: 100%; padding: 8px 10px; background: #0e1520; color: var(--text); border: 1px solid #243244; border-radius: 10px; outline: none; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    button { width: 100%; padding: 10px 12px; margin-top: 12px; background: #123a57; color: var(--text); border: 1px solid #29597a; border-radius: 12px; cursor: pointer; font-weight: 600; }
    button:hover { filter: brightness(1.05); }
    .btn-secondary { background: #1a2330; border-color: #2b3b50; }
    .hint { font-size: 12px; color: var(--muted); margin-top: 6px; }
    .list { margin-top: 14px; display: grid; gap: 8px; }
    .card { background: #0e1520; border: 1px solid #202e41; border-radius: 12px; padding: 10px; }
    .card h3 { font-size: 14px; margin: 0 0 6px; }
    .pill { display: inline-block; padding: 3px 8px; border: 1px solid #2b3b50; border-radius: 999px; font-size: 12px; margin-right: 6px; color: var(--muted); }
    .status { font-size: 12px; }
    .status.ok { color: var(--ok); }
    .status.err { color: var(--danger); }
    .thumb { width: 100%; height: 140px; object-fit: cover; border-radius: 10px; background: #0b0f14; border: 1px solid #1b2736; }
    .actions { display: flex; gap: 8px; margin-top: 8px; }
    .small { font-size: 12px; }
    .sep { height: 1px; background: #1d2935; margin: 12px 0; }
      /* progress bar */
    .progress { height: 8px; background: #0b0f14; border: 1px solid #1b2736; border-radius: 999px; overflow: hidden; margin-top: 8px; }
    .progress > .bar { height: 100%; width: 0%; background: linear-gradient(90deg, rgba(124,193,255,.9), rgba(124,193,255,.4)); transition: width .25s ease; }
    .progress-msg { font-size: 12px; color: var(--muted); margin-top: 6px; }
  </style>
</head>
<body>
  <aside id="sidebar">
    <h1>GE‑S2DR3 — Minimal WebGIS</h1>
    <div class="muted small">Free basemap • Lat/Lon + dates → call Gamma Earth API → overlay results</div>

    <label>Latitude</label>
    <input id="lat" type="text" placeholder="e.g., 45.4642" />

    <label>Longitude</label>
    <input id="lon" type="text" placeholder="e.g., 9.1900" />

    <label>Dates</label>
    <textarea id="dates" rows="3" placeholder="YYYYMMDD or YYYY-MM-DD; comma or newline separated"></textarea>
    <div class="hint">Tip: paste multiple dates, e.g. <code>2024-05-02, 2024-07-18, 2024-10-11</code></div>

    <div class="row">
      <select id="product">
        <option value="MS" selected>MS (10-band)</option>
        <option value="TCI">TCI (RGB)</option>
        <option value="NDVI">NDVI</option>
        <option value="IRP">IRP</option>
      </select>
      <select id="zoom">
        <option>10</option>
        <option>12</option>
        <option selected>14</option>
        <option>15</option>
      </select>
    </div>
    <div class="hint">Product & preferred zoom (used if API supports it)</div>

    <button id="runBtn">Run inference</button>
    <button id="clearBtn" class="btn-secondary">Clear overlays</button>

    <div class="sep"></div>
    <div class="muted small">Results</div>
    <div id="results" class="list"></div>
  </aside>

  <div id="map"></div>

  <!-- Leaflet -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>
  <!-- Optional: GeoTIFF rendering if the API returns COGs -->
  <script src="https://unpkg.com/geotiff@2.1.3/dist-browser/geotiff.min.js"></script>
  <script src="https://unpkg.com/georaster@1.6.1/dist/georaster.browser.min.js"></script>
  <script src="https://unpkg.com/georaster-layer-for-leaflet@3.18.0/dist/georaster-layer-for-leaflet.min.js"></script>

  <script>
    // =====================
    // Config — EDIT THESE
    // =====================
    const CONFIG = {
      API_URL: "https://YOUR-GAMMA-EARTH-ENDPOINT/run", // e.g., https://api.gamma.earth/s2dr3/run (placeholder)
      AUTH_TOKEN: "", // e.g., "Bearer xxx" (optional)
      USE_POLLING: false, // set true if API returns a job id to poll
      JOB_STATUS_URL: (jobId) => `https://YOUR-GAMMA-EARTH-ENDPOINT/jobs/${jobId}`,
      MAP_START: { lat: 45.4642, lon: 9.19, zoom: 7 }, // Milan-ish as default
    };

    // Leaflet map init
    const map = L.map('map').setView([CONFIG.MAP_START.lat, CONFIG.MAP_START.lon], CONFIG.MAP_START.zoom);
    const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    const overlays = []; // track layers we add

    // DOM elements
    const el = (id) => document.getElementById(id);
    const latInput = el('lat');
    const lonInput = el('lon');
    const datesInput = el('dates');
    const productInput = el('product');
    const zoomInput = el('zoom');
    const resultsDiv = el('results');

    // Helper: parse dates (comma or newline separated)
    function parseDates(raw) {
      return Array.from(new Set(
        raw
          .split(/[\n,]+/)
          .map(s => s.trim())
          .filter(Boolean)
      ));
    }

    function notify(msg, type = 'info') {
      console[type === 'error' ? 'error' : 'log'](msg);
    }

    function addMarker(lat, lon) {
      const marker = L.marker([lat, lon]).addTo(map);
      overlays.push(marker);
      return marker;
    }

    function clearOverlays() {
      overlays.forEach(lyr => map.removeLayer(lyr));
      overlays.length = 0;
      resultsDiv.innerHTML = '';
    }

    el('clearBtn').addEventListener('click', clearOverlays);

    function addResultCard({ id, date, status = 'queued', thumb, links = {}, layerRef = null, extra = {} }) {
      const card = document.createElement('div');
      card.className = 'card';
      card.dataset.resultId = id;
      card.innerHTML = `
        ${thumb ? `<img class="thumb" src="${thumb}" alt="thumb">` : ''}
        <h3>${date ? date : 'Result'}</h3>
        <div class="status ${status==='ok'?'ok':status==='error'?'err':''}">Status: ${status}</div>
        <div class="progress"><div class="bar"></div></div>
        <div class="progress-msg"></div>
        <div class="hint small">${extra.message || ''}</div>
        <div class="actions">
          ${layerRef ? '<button class="btn-zoom">Zoom to</button>' : ''}
          ${links.download ? `<a class="btn-secondary" href="${links.download}" target="_blank" rel="noopener">Download</a>` : ''}
          ${links.view ? `<a class="btn-secondary" href="${links.view}" target="_blank" rel="noopener">Open</a>` : ''}
        </div>`;

      if (layerRef) {
        const zoomBtn = card.querySelector('.btn-zoom');
        if (zoomBtn) {
          zoomBtn.addEventListener('click', () => {
            if (layerRef.getBounds) {
              map.fitBounds(layerRef.getBounds());
            } else if (layerRef.getLatLng) {
              map.setView(layerRef.getLatLng(), 14);
            }
          });
        }
      }
      resultsDiv.prepend(card);
      return card;
    }

    function setCardProgress(card, pct, msg = '') {
      try {
        const bar = card.querySelector('.bar');
        const msgEl = card.querySelector('.progress-msg');
        if (typeof pct === 'number' && !Number.isNaN(pct)) {
          const clamped = Math.max(0, Math.min(100, pct));
          bar.style.width = clamped + '%';
        }
        if (msgEl) msgEl.textContent = msg;
      } catch (_) {}
    }

    // Try to add overlay from various API response shapes
    async function addOverlayFromAssets(assets, opts = {}) {
      // Supported shapes (any subset):
      // - assets.tms_url                (string) templated tile URL
      // - assets.png_url + bounds       (string + [[s,w],[n,e]])
      // - assets.cog_url                (string) Cloud Optimized GeoTIFF
      // - assets.geojson                (object | url)
      // - assets.thumbnail_url          (string)

      if (assets.tms_url) {
        const layer = L.tileLayer(assets.tms_url, { maxZoom: 22, opacity: 0.9 });
        layer.addTo(map);
        overlays.push(layer);
        return { layer, thumb: assets.thumbnail_url || null, bounds: null, link: assets.tms_url };
      }

      if (assets.png_url && assets.bounds) {
        const b = assets.bounds; // [[south, west], [north, east]]
        const bounds = L.latLngBounds([b[0][0], b[0][1]], [b[1][0], b[1][1]]);
        const layer = L.imageOverlay(assets.png_url, bounds, { opacity: 0.95 }).addTo(map);
        overlays.push(layer);
        return { layer, thumb: assets.thumbnail_url || assets.png_url, bounds, link: assets.png_url };
      }

      if (assets.cog_url) {
        const tiff = await GeoTIFF.fromUrl(assets.cog_url);
        const image = await tiff.getImage();
        const ras = await parseGeoraster(assets.cog_url); // georaster auto-reads COG
        const layer = new GeoRasterLayer({ georaster: ras, opacity: 0.95, resolution: 256 });
        layer.addTo(map);
        overlays.push(layer);
        try {
          const bbox = image.getBoundingBox(); // [minX, minY, maxX, maxY] in WGS84
          const bounds = L.latLngBounds([bbox[1], bbox[0]], [bbox[3], bbox[2]]);
          return { layer, thumb: assets.thumbnail_url || null, bounds, link: assets.cog_url };
        } catch (e) {
          return { layer, thumb: assets.thumbnail_url || null, bounds: null, link: assets.cog_url };
        }
      }

      // Fallback: nothing to overlay
      return { layer: null, thumb: assets.thumbnail_url || null, bounds: null, link: null };
    }

    async function runGammaInferenceOne({ lat, lon, date, product, zoom }) {
      const queuedCard = addResultCard({ id: `req-${date}-${Date.now()}`, date, status: 'queued' });
      setCardProgress(queuedCard, 3, 'Submitting request…');

      try {
        const payload = { lat: Number(lat), lon: Number(lon), date, product_type: product, zoom: Number(zoom) };
        const headers = { 'Content-Type': 'application/json' };
        if (CONFIG.AUTH_TOKEN) headers['Authorization'] = CONFIG.AUTH_TOKEN;

        const resp = await fetch(CONFIG.API_URL, { method: 'POST', headers, body: JSON.stringify(payload) });
        if (!resp.ok) throw        let assets = data.assets;
        if (!assets && CONFIG.USE_POLLING && data.job_id) {
          assets = await pollForAssets(data.job_id);
        }

        if (!assets) throw new Error('No assets returned by API');

        // 3) Add overlay(s)
        const added = await addOverlayFromAssets(assets, { product, date });

        // 4) Add marker (center)
        const m = addMarker(lat, lon);

        // 5) Update the card
        queuedCard.querySelector('.status').textContent = 'Status: ok';
        queuedCard.querySelector('.status').classList.add('ok');
        if (added.thumb) {
          const imgel = document.createElement('img');
          imgel.className = 'thumb';
          imgel.src = added.thumb;
          queuedCard.insertBefore(imgel, queuedCard.firstChild);
        }

        // Update links
        const act = queuedCard.querySelector('.actions');
        act.innerHTML = '';
        if (added.layer) {
          const btn = document.createElement('button');
          btn.textContent = 'Zoom to';
          btn.addEventListener('click', () => {
            if (added.layer.getBounds) map.fitBounds(added.layer.getBounds());
          });
          act.appendChild(btn);
        }
        if (added.link) {
          const a = document.createElement('a');
          a.className = 'btn-secondary';
          a.href = added.link; a.target = '_blank'; a.rel = 'noopener';
          a.textContent = 'Open';
          act.appendChild(a);
        }

        return true;
      } catch (err) {
        console.error(err);
        queuedCard.querySelector('.status').textContent = 'Status: error';
        queuedCard.querySelector('.status').classList.add('err');
        queuedCard.querySelector('.hint').textContent = err.message;
        return false;
      }
    }

    async function pollForAssets(jobId, onProgress = () => {}) {
      const headers = {};
      if (CONFIG.AUTH_TOKEN) headers['Authorization'] = CONFIG.AUTH_TOKEN;

      const t0 = Date.now();
      const TIMEOUT_MS = 10 * 60 * 1000; // up to 10 minutes
      let interval = 2000;

      while (Date.now() - t0 < TIMEOUT_MS) {
        const u = CONFIG.JOB_STATUS_URL(jobId);
        const r = await fetch(u, { headers, cache: 'no-store' });
        if (!r.ok) throw new Error(`Job status HTTP ${r.status}`);
        const j = await r.json();

        // Try common progress field shapes
        const pct = j.progress?.percent ?? j.percent ?? j.status?.percent ?? j.progress ?? null;
        const msg = j.message || j.status?.message || j.phase || '';
        if (pct != null) onProgress(Math.round(Number(pct)), msg);
        else onProgress(null, msg);

        if ((j.status === 'succeeded' || j.state === 'succeeded' || j.done === true) && j.assets) return j.assets;
        if (j.status === 'failed' || j.state === 'failed' || j.error) throw new Error(j.error || 'Job failed');

        await new Promise(res => setTimeout(res, interval));
        // gentle backoff up to 6s
        interval = Math.min(6000, Math.round(interval * 1.2));
      }
      throw new Error('Timed out waiting for job');
    };
      if (CONFIG.AUTH_TOKEN) headers['Authorization'] = CONFIG.AUTH_TOKEN;

      const t0 = Date.now();
      const TIMEOUT_MS = 5 * 60 * 1000; // 5 minutes
      const INTERVAL_MS = 2500;

      while (Date.now() - t0 < TIMEOUT_MS) {
        const u = CONFIG.JOB_STATUS_URL(jobId);
        const r = await fetch(u, { headers });
        if (!r.ok) throw new Error(`Job status HTTP ${r.status}`);
        const j = await r.json();
        if (j.status === 'succeeded' && j.assets) return j.assets;
        if (j.status === 'failed') throw new Error(j.error || 'Job failed');
        await new Promise(res => setTimeout(res, INTERVAL_MS));
      }
      throw new Error('Timed out waiting for job');
    }

    // Wire up submit
    el('runBtn').addEventListener('click', async () => {
      const lat = parseFloat(latInput.value);
      const lon = parseFloat(lonInput.value);
      const dates = parseDates(datesInput.value);
      const product = productInput.value;
      const zoom = parseInt(zoomInput.value, 10);

      if (Number.isNaN(lat) || Number.isNaN(lon)) { return notify('Invalid lat/lon', 'error'); }
      if (dates.length === 0) { return notify('Add at least one date', 'error'); }

      // Center map and drop a temp marker
      map.setView([lat, lon], Math.max(10, zoom));

      for (const date of dates) {
        // fire sequentially to keep UI stable (can parallelize if needed)
        // eslint-disable-next-line no-await-in-loop
        await runGammaInferenceOne({ lat, lon, date, product, zoom });
      }
    });

    // Optional: Fill with sample values for quick testing
    latInput.value = '45.4642';
    lonInput.value = '9.1900';
    datesInput.value = '2024-07-18, 2024-10-11';
  </script>
</body>
</html>
