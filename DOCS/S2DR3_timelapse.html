<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>S2DR3 Timelapse ‚Äî Minimal Probe</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    /* --- UI basics --- */
    body { font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial; margin: 1rem; }
    .row { display: grid; grid-template-columns: repeat(6, 1fr); gap: 12px; margin-bottom: 12px; }
    .card { border: 1px solid #ddd; border-radius: 8px; padding: 12px; }
    label { display: block; font-weight: 600; margin-bottom: 4px; }
    input, select, button { padding: 8px 10px; font-size: 14px; width: 100%; }
    button { cursor: pointer; }
    #msg { margin-top: 8px; color: #333; }
    #thumbs { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px,1fr)); gap: 10px; margin-top: 12px; }

    /* --- thumbnails --- */
    .thumb { position: relative; border: 1px solid #eee; border-radius: 8px; overflow: hidden; }
    .thumb img { display:block; width:100%; height:160px; object-fit:cover; }
    .cap { padding:6px 8px; font-size: 12px; background: #fafafa; border-top:1px solid #eee; }

    /* per-card remove button */
    .thumb .rm {
      position: absolute; top: 6px; right: 6px;
      border: 0; border-radius: 999px; width: 26px; height: 26px; line-height: 26px;
      font-size: 16px; background: rgba(0,0,0,.6); color: #fff;
      display: grid; place-items: center; padding: 0;
    }
    .thumb .rm:hover { background: rgba(0,0,0,.75); }
  </style>
</head>

<body>
  <h1>S2DR3 Minimal Date Probe</h1>
  <p>Use this to debug ‚ÄúAdd date‚Äù and build a timelapse without external map libs. Open DevTools ‚Üí Console for logs.<br>Test dates: 20180812, 20230816, 20250815</p>

  <div class="card">
    <!-- --- Probe form --- -->
    <div class="row">
      <div>
        <label for="lon">Longitude</label>
        <input id="lon" type="number" step="0.0001" placeholder="45.023" value="45.023">
      </div>
      <div>
        <label for="lat">Latitude</label>
        <input id="lat" type="number" step="0.0001" placeholder="-20.5228" value="-20.5228">
      </div>
      <div>
        <label for="preferExact">Prefer exact zoom</label>
        <div style="display:flex;gap:.5rem;align-items:center">
          <input id="preferExact" type="checkbox" checked>
          <span>Sequential probe (z ‚Üí 12 ‚Üí 10)</span>
        </div>
      </div>
      <div>
        <label for="zoom">Zoom</label>
        <input id="zoom" type="number" min="1" max="19" value="15">
      </div>
      <div>
        <label for="fallback">Zoom fallback</label>
        <div style="display:flex;gap:.5rem;align-items:center">
          <input id="fallback" type="checkbox">
          <span>Allow zoom fallback (12, 10)</span>
        </div>
      </div>
      <div>
        <label for="lockCenter">Lock to tile center</label>
        <div style="display:flex;gap:.5rem;align-items:center">
          <input id="lockCenter" type="checkbox">
          <span>After success, set lon/lat to the tile‚Äôs center</span>
        </div>
      </div>
      <div style="grid-column: span 3;">
        <label for="ds">Output ID (ds)</label>
        <input id="ds" type="text" placeholder="MG-T38KMC-e0a95e3ea" value="MG-T38KMC-e0a95e3ea">
      </div>
    </div>

    <div class="row">
      <div>
        <label for="type">Type</label>
        <select id="type">
          <option>RGB</option>
          <option>IRP</option>
          <option>NDVI</option>
        </select>
      </div>
      <div>
        <label for="date">Date (YYYYMMDD)</label>
        <input id="date" type="text" maxlength="8" placeholder="20180812" value="20180812">
      </div>
      <div style="grid-column: span 4; display:flex; align-items:end; gap:10px;">
        <button id="add" type="button">‚ûï Add date (probe & thumbnail)</button>
        <button id="clear" type="button">üßπ Clear all</button>
      </div>
    </div>

    <!-- --- Encode settings --- -->
    <div class="row">
      <div>
        <label for="fps">FPS</label>
        <input id="fps" type="number" min="1" max="60" value="24">
      </div>
      <div>
        <label for="aspect">Aspect</label>
        <select id="aspect">
          <option value="square">Square 1080√ó1080</option>
          <option value="landscape">Landscape 1920√ó1080</option>
          <option value="vertical">Vertical 1080√ó1920</option>
        </select>
      </div>
      <div style="grid-column: span 4; display:flex; align-items:end; gap:10px;">
        <button id="gen" type="button">üé¨ Generate timelapse</button>
        <div id="encmsg" class="muted">Encoder idle</div>
      </div>
    </div>

    <!-- progress bar -->
    <div class="row" style="align-items:center">
      <div style="grid-column: span 6;">
        <div id="bar" style="height:8px;background:#eee;border-radius:6px;overflow:hidden;">
          <div id="barfill" style="height:100%;width:0%;background:linear-gradient(90deg,#0eb2ff,#67e8a3)"></div>
        </div>
      </div>
    </div>

    <!-- downloads -->
    <div class="row" style="align-items:center">
      <div style="grid-column: span 6; display:flex; gap:10px; flex-wrap:wrap;">
        <a id="dl-mp4" class="btn" download="timelapse.mp4" style="display:none">‚¨áÔ∏è MP4</a>
        <a id="dl-webm" class="btn" download="timelapse.webm" style="display:none">‚¨áÔ∏è WebM</a>
      </div>
    </div>

    <div id="msg">Ready. Open DevTools ‚Üí Console for logs.</div>
  </div>

  <div id="thumbs"></div>

  <!--
    IMPORTANT: Keep this script as "module" because we dynamically import the local ESM wrapper.
    We host the wrapper (and its worker.js) on the same origin to avoid cross-origin worker blocks.
    The big .wasm stays on jsDelivr and is referenced by corePath/coreURL.
  -->
  <script type="module">
  /* =========================
     0) Globals and UI helpers
     ========================= */
  const lambdaBase = "https://kgbbmarmdgv53gdb47pls2v2oe0qotcs.lambda-url.eu-central-1.on.aws/cog/tiles/WebMercatorQuad";
  const thumbs   = document.getElementById("thumbs");
  const msg      = document.getElementById("msg");
  const encmsg   = document.getElementById("encmsg");
  const barfill  = document.getElementById("barfill");
  const dlMp4    = document.getElementById("dl-mp4");
  const dlWebm   = document.getElementById("dl-webm");
  const DEBUG = true;

  const frames = []; // [{ date, idx, z, url }]
  const byDate = (a,b) => a.date.localeCompare(b.date);
  const setMsg = (t) => { msg.textContent = t; };
  const setEncMsg = (t) => { encmsg.textContent = t; };
  const setBar = (pct) => { barfill.style.width = Math.max(0,Math.min(100,pct)) + "%"; };
  const validDate = (s) => /^\d{8}$/.test(s);
  const nice = (d) => `${d.slice(0,4)}-${d.slice(4,6)}-${d.slice(6)}`;

  function renderThumbs(){
    thumbs.innerHTML = "";
    frames.sort(byDate).forEach((f, i) => {
      const wrap = document.createElement("div");
      wrap.className = "thumb";

      const btn = document.createElement("button");
      btn.className = "rm";
      btn.type = "button";
      btn.title = "Remove";
      btn.textContent = "√ó";
      btn.onclick = () => {
        frames.splice(i, 1);
        renderThumbs();
        setMsg("Removed thumbnail.");
      };

      const img = document.createElement("img");
      img.src = f.url;

      const cap = document.createElement("div");
      cap.className = "cap";
      cap.textContent = `${nice(f.date)} ‚Ä¢ ${f.idx.toUpperCase()} ‚Ä¢ z${f.z}`;

      wrap.append(btn, img, cap);
      thumbs.appendChild(wrap);
    });
  }

  /* ========================
     1) Tile URL construction
     ======================== */
  const parseDs = (ds) => {
    const p = (ds||"").split("-");
    return { country: p[0], tile: p[1], uid: p[2] };
  };
  function productSuffix(idx){
    if (idx === "rgb") return "_TCI.tif";
    if (idx === "ndvi") return "_NDVI.tif";
    if (idx === "irp" || idx === "fcir") return "_IRP.tif";
    return "_TCI.tif";
  }
  function tilesFor(country, tile, uid, date, idx){
    const P = `${tile}-${uid}-${date}`;
    const root = `${lambdaBase}/{z}/{x}/{y}@2x?url=s3://sentinel-s2dr3/${country}/${tile}/${P}`;
    const suffix = productSuffix(idx);
    return [`${root}/S2L2Ax10_${P}${suffix}`];
  }

  /* ===========================
     2) Tile math & probing
     =========================== */
  function lonLatToTile(lon, lat, z) {
    const x = Math.floor(((lon + 180) / 360) * Math.pow(2, z));
    const y = Math.floor(
      ((1 - Math.log(Math.tan((lat * Math.PI) / 180) + 1 / Math.cos((lat * Math.PI) / 180)) / Math.PI) / 2) *
      Math.pow(2, z)
    );
    return { x, y };
  }
  function tileCenterLonLat(z, x, y){
    const n = Math.pow(2, z);
    const lon = (x + 0.5) / n * 360 - 180;
    const t = Math.PI - 2 * Math.PI * (y + 0.5) / n;
    const lat = (180 / Math.PI) * Math.atan(Math.sinh(t));
    return { lon, lat };
  }

  // Load an image with timeout; resolve { ok, url }.
  // Optional retryDelays: extra attempts after the first timeout.
  // e.g. [2000, 4000] => try once (t0), then again after 2s (t1), then again after 4s (t2).
  async function loadImgWithRetry(url, firstTimeoutMs = 2500, retryDelays = []) {
    const tryOnce = (u, toMs) => new Promise((resolve) => {
      const img = new Image();
      let settled = false;
      const done = (ok) => { if (!settled) { settled = true; resolve({ ok, url: u }); } };
      const to = setTimeout(() => done(false), toMs);
      img.onload  = () => { clearTimeout(to); done(true); };
      img.onerror = () => { clearTimeout(to); done(false); };
      img.crossOrigin = "anonymous";
      img.src = u;
    });
  
    // first attempt
    let res = await tryOnce(url, firstTimeoutMs);
    if (res.ok) return res;
  
    // retries (same URL; server likely warming up)
    for (const extraMs of retryDelays) {
      // small pause before retry
      await new Promise(r => setTimeout(r, 120));
      res = await tryOnce(url, extraMs);
      if (res.ok) return res;
    }
    return res; // last failure
  }


  // Probe a date at target zoom; optionally fallback to 12,10.
  // Sequential probe with strong preference for the requested zoom.
  // We *retry* the exact zoom a few times (progressive timeouts) before falling back.
  async function probeDate(ds, idx, date, lon, lat, zoom, allowFallback, preferExact) {
    const { country, tile, uid } = parseDs(ds);
    if (!country || !tile || !uid) {
      alert("ds must be COUNTRY-TILE-UID (e.g., MG-T38KMC-e0a95e3ea)");
      return { ok:false };
    }
    const tmpl = tilesFor(country, tile, uid, date, idx)[0];
    const z0 = Math.max(0, Math.round(zoom));
    const zList = allowFallback ? [z0, 12, 10].filter((z, i, a) => a.indexOf(z) === i) : [z0];
  
    const urlForZ = (zc) => {
      const { x, y } = lonLatToTile(lon, lat, zc);
      const url = tmpl.replace("{z}", zc).replace("{x}", x).replace("{y}", y) +
                  (tmpl.includes("?") ? "&" : "?") + "_cb=" + Date.now();
      return { url, x, y, z: zc };
    };
  
    // Always sequential; preferExact translates to "try harder on exact zoom"
    const exact = urlForZ(zList[0]);
  
    // Heavier retries for the exact zoom (tune these if needed)
    // First try 3.5s, then 5.5s, then 7.5s. This usually covers cold starts.
    if (DEBUG) console.log(`[probe:seq] exact z${exact.z} ${date} ‚Üí`, exact.url);
    let res = await loadImgWithRetry(exact.url, 3500, preferExact ? [5500, 7500] : [2500]);
    if (res.ok) return { ok:true, url: exact.url, z: exact.z, x: exact.x, y: exact.y };
  
    // Only after exhausting exact zoom, try the remaining fallbacks (shorter timeouts)
    for (let i = 1; i < zList.length; i++) {
      const alt = urlForZ(zList[i]);
      if (DEBUG) console.log(`[probe:seq] fallback z${alt.z} ${date} ‚Üí`, alt.url);
      res = await loadImgWithRetry(alt.url, 2500, [3500]);
      if (res.ok) return { ok:true, url: alt.url, z: alt.z, x: alt.x, y: alt.y };
    }
  
    return { ok:false };
  }


  /* =======================
     3) Add/clear UI actions
     ======================= */
  document.getElementById("add").addEventListener("click", async () => {
    const lon  = parseFloat(document.getElementById("lon").value);
    const lat  = parseFloat(document.getElementById("lat").value);
    const zoom = parseInt(document.getElementById("zoom").value, 10);
    const ds   = (document.getElementById("ds").value || "").trim();
    const typeUi = document.getElementById("type").value;
    const idx  = (typeUi === "RGB") ? "rgb" : (typeUi === "IRP") ? "irp" : "ndvi";
    const date = (document.getElementById("date").value || "").trim();
    const allowFallback = document.getElementById("fallback").checked;
    const lockCenter = document.getElementById("lockCenter").checked;
    const preferExact = document.getElementById("preferExact").checked; // NEW

    if (!ds) { alert("Missing output_id (ds)"); return; }
    if (!validDate(date)) { alert("Date must be YYYYMMDD"); return; }
    if (!Number.isFinite(lon) || !Number.isFinite(lat)) { alert("Bad lon/lat"); return; }
    if (!Number.isFinite(zoom)) { alert("Bad zoom"); return; }

    if (frames.some(f => f.date === date && f.idx === idx)) {
      alert(`Date ${date} (${idx.toUpperCase()}) is already added.`);
      return;
    }

    setMsg("Probing tiles‚Ä¶ (see Console)");
    const res = await probeDate(ds, idx, date, lon, lat, zoom, allowFallback, preferExact);
    if (!res.ok) {
      setMsg(`No tiles for ${idx.toUpperCase()} on ${nice(date)} at z${zoom}${allowFallback ? " (no fallback worked)" : ""}.`);
      return;
    }

    if (lockCenter && Number.isFinite(res.z) && Number.isFinite(res.x) && Number.isFinite(res.y)) {
      const c = tileCenterLonLat(res.z, res.x, res.y);
      document.getElementById("lon").value = c.lon.toFixed(6);
      document.getElementById("lat").value = c.lat.toFixed(6);
      document.getElementById("zoom").value = String(res.z);
      setMsg(`Found tiles for ${nice(date)} ‚Äî z${res.z}. Locked lon/lat to tile center.`);
    } else {
      setMsg(`Found tiles for ${nice(date)} ‚Äî z${res.z}.`);
    }

    frames.push({ date, idx, z: res.z, url: res.url });
    renderThumbs();
  });

  document.getElementById("clear").addEventListener("click", () => {
    frames.length = 0;
    renderThumbs();
    setMsg("Cleared all thumbnails.");
  });

  /* ============================================================
     4) ffmpeg.wasm loader (wrapper = same-origin ESM; core = CDN)
     ============================================================ */
  let ffmpeg = null;

  async function getFF() {
    if (ffmpeg) return ffmpeg;

    // Import the wrapper from YOUR repo (ensures worker.js is same‚Äëorigin)
    const wrapperUrl = "./vendor/ffmpeg/esm/index.js?v=1";
    const mod = await import(wrapperUrl);

    const create = (typeof mod.createFFmpeg === "function")
      ? mod.createFFmpeg
      : (mod.default && typeof mod.default.createFFmpeg === "function")
        ? mod.default.createFFmpeg
        : null;

    const Klass = (typeof mod.FFmpeg === "function")
      ? mod.FFmpeg
      : (mod.default && typeof mod.default.FFmpeg === "function")
        ? mod.default.FFmpeg
        : null;

    const coreESM = "https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.10/dist/esm/ffmpeg-core.js";

    if (create) {
      const inst = create({ log: true, corePath: coreESM });
      inst.on?.("log", ({ message }) => { if (message) setEncMsg(message); });
      await inst.load();
      ffmpeg = inst;
      return ffmpeg;
    }
    if (Klass) {
      const inst = new Klass();
      inst.on?.("log", ({ message }) => { if (message) setEncMsg(message); });
      await inst.load({ coreURL: coreESM });
      ffmpeg = inst;
      return ffmpeg;
    }

    console.error("FF wrapper exports:", Object.keys(mod), "default keys:", mod && mod.default ? Object.keys(mod.default) : "(none)");
    throw new Error("FFmpeg wrapper loaded but no createFFmpeg/FFmpeg export was found.");
  }

  // FS/exec compatibility across both APIs
  async function ffEnsureDir(ff, path) {
    if (ff.FS) { try { ff.FS("readdir", path); } catch { ff.FS("mkdir", path); } }
    else { try { await ff.listDir(path); } catch { await ff.createDir(path); } }
  }
  async function ffWrite(ff, path, data) {
    if (ff.FS) ff.FS("writeFile", path, data);
    else await ff.writeFile(path, data);
  }
  async function ffRead(ff, path) {
    if (ff.FS) return ff.FS("readFile", path);
    return await ff.readFile(path);
  }
  async function ffRun(ff, ...args) {
    if (typeof ff.run === "function") return ff.run(...args);
    if (typeof ff.exec === "function") return ff.exec(args);
    throw new Error("FFmpeg exec interface not found");
  }

  /* ===========================
     5) Encoding: image -> video
     =========================== */
  function aspectToWxH(aspect) {
    if (aspect === "landscape") return { w: 1920, h: 1080 };
    if (aspect === "vertical")  return { w: 1080, h: 1920 };
    return { w: 1080, h: 1080 };
  }

  async function fetchImageBytes(url) {
    const r = await fetch(url, { mode: "cors" });
    if (!r.ok) throw new Error(`Fetch failed ${r.status}`);
    const b = await r.arrayBuffer();
    return new Uint8Array(b);
  }

  async function encodeTimelapse(sortedFrames, fps, aspect) {
    const { w, h } = aspectToWxH(aspect);
    const ff = await getFF();

    await ffEnsureDir(ff, "/frames");
    await ffEnsureDir(ff, "/out");

    setEncMsg("Downloading frames‚Ä¶");
    setBar(5);

    for (let i = 0; i < sortedFrames.length; i++) {
      const f = sortedFrames[i];
      const bytes = await fetchImageBytes(f.url);
      const name = `/frames/frame${String(i).padStart(3, "0")}.jpg`;
      await ffWrite(ff, name, bytes);
      setBar(5 + Math.floor((i + 1) / sortedFrames.length * 35)); // ‚Üí 40%
    }

    const vf = `scale=w='min(${w},iw*min(${w}/iw\\,${h}/ih))':h='min(${h},ih*min(${w}/iw\\,${h}/ih))',pad=${w}:${h}:(ow-iw)/2:(oh-ih)/2:black`;

    setEncMsg("Encoding MP4‚Ä¶");
    let mp4Data = null, webmData = null;

    try {
      await ffRun(
        ff,
        "-framerate", String(fps),
        "-i", "/frames/frame%03d.jpg",
        "-vf", vf,
        "-c:v", "libx264",
        "-pix_fmt", "yuv420p",
        "-movflags", "+faststart",
        "/out/timelapse.mp4"
      );
      mp4Data = await ffRead(ff, "/out/timelapse.mp4");
    } catch (e) {
      console.warn("MP4 encode failed, falling back to WebM.", e);
    }
    setBar(85);

    if (!mp4Data) {
      setEncMsg("Encoding WebM fallback‚Ä¶");
      await ffRun(
        ff,
        "-framerate", String(fps),
        "-i", "/frames/frame%03d.jpg",
        "-vf", vf,
        "-c:v", "libvpx-vp9",
        "-b:v", "2M",
        "/out/timelapse.webm"
      );
      webmData = await ffRead(ff, "/out/timelapse.webm");
    }
    setBar(100);

    return { mp4Data, webmData };
  }

  /* =========================
     6) Generate button action
     ========================= */
  document.getElementById("gen").addEventListener("click", async () => {
    if (frames.length === 0) { alert("Add at least one date first."); return; }

    const fps = Math.max(1, Math.min(60, parseInt(document.getElementById("fps").value || "24", 10)));
    const aspect = document.getElementById("aspect").value;
    const sorted = [...frames].sort(byDate);

    setEncMsg("Preparing encoder‚Ä¶");
    setBar(0);
    dlMp4.style.display = "none";
    dlWebm.style.display = "none";

    try {
      const { mp4Data, webmData } = await encodeTimelapse(sorted, fps, aspect);

      if (mp4Data && mp4Data.length) {
        const blob = new Blob([mp4Data.buffer], { type: "video/mp4" });
        dlMp4.href = URL.createObjectURL(blob);
        dlMp4.style.display = "inline-block";
        setEncMsg("Done! MP4 ready üéâ");
      } else if (webmData && webmData.length) {
        const blob = new Blob([webmData.buffer], { type: "video/webm" });
        dlWebm.href = URL.createObjectURL(blob);
        dlWebm.style.display = "inline-block";
        setEncMsg("MP4 not available ‚Äî WebM provided ‚úÖ");
      } else {
        setEncMsg("Encoding failed.");
      }
    } catch (e) {
      console.error(e);
      setEncMsg("Encoding error. See console.");
    }
  });
</script>

</body>
</html>
