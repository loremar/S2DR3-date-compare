<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>S2DR3 Timelapse ‚Äî Minimal Probe</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body { font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial; margin: 1rem; }
    .row { display: grid; grid-template-columns: repeat(6, 1fr); gap: 12px; margin-bottom: 12px; }
    .card { border: 1px solid #ddd; border-radius: 8px; padding: 12px; }
    label { display: block; font-weight: 600; margin-bottom: 4px; }
    input, select, button { padding: 8px 10px; font-size: 14px; width: 100%; }
    button { cursor: pointer; }
    #msg { margin-top: 8px; color: #333; }
    #thumbs { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px,1fr)); gap: 10px; margin-top: 12px; }
    .thumb { position: relative; border: 1px solid #eee; border-radius: 8px; overflow: hidden; }
    .thumb img { display:block; width:100%; height:160px; object-fit:cover; }
    .cap { padding:6px 8px; font-size: 12px; background: #fafafa; border-top:1px solid #eee; }
    /* per-card remove button */
    .thumb .rm {
      position: absolute; top: 6px; right: 6px;
      border: 0; border-radius: 999px;
      width: 26px; height: 26px; line-height: 26px;
      font-size: 16px; background: rgba(0,0,0,.6); color: #fff;
      display: grid; place-items: center; padding: 0;
    }
    .thumb .rm:hover { background: rgba(0,0,0,.75); }
  </style>
</head>
<body>
  <h1>S2DR3 Minimal Date Probe</h1>
  <p>Use this to debug ‚ÄúAdd date‚Äù without any external libraries. Open the browser console to see detailed logs.<br>test dates: 20180812, 20230816, 20250815</p>

  <div class="card">
    <div class="row">
      <div>
        <label for="lon">Longitude</label>
        <input id="lon" type="number" step="0.0001" placeholder="45.023" value="45.023">
      </div>
      <div>
        <label for="lat">Latitude</label>
        <input id="lat" type="number" step="0.0001" placeholder="-20.5228" value="-20.5228">
      </div>
      <div>
        <label for="zoom">Zoom</label>
        <input id="zoom" type="number" min="1" max="19" value="15">
      </div>
      <div>
        <label for="fallback">Zoom fallback</label>
        <div style="display:flex;gap:.5rem;align-items:center">
          <input id="fallback" type="checkbox" checked>
          <span>Allow zoom fallback (12, 10)</span>
        </div>
      </div>
      <div>
        <label for="lockCenter">Lock to tile center</label>
        <div style="display:flex;gap:.5rem;align-items:center">
          <input id="lockCenter" type="checkbox" checked>
          <span>After success, set lon/lat to the tile‚Äôs center</span>
        </div>
      </div>
      <div style="grid-column: span 3;">
        <label for="ds">Output ID (ds)</label>
        <input id="ds" type="text" placeholder="MG-T38KMC-e0a95e3ea" value="MG-T38KMC-e0a95e3ea">
      </div>
    </div>

    <div class="row">
      <div>
        <label for="type">Type</label>
        <select id="type">
          <option>RGB</option>
          <option>IRP</option>
          <option>NDVI</option>
        </select>
      </div>
      <div>
        <label for="date">Date (YYYYMMDD)</label>
        <input id="date" type="text" maxlength="8" placeholder="20180812" value="20180812">
      </div>
      <div style="grid-column: span 4; display:flex; align-items:end; gap:10px;">
        <button id="add" type="button">‚ûï Add date (probe & thumbnail)</button>
        <button id="clear" type="button">üßπ Clear all</button>
      </div>
    </div>
   
    <div class="row">
      <div>
        <label for="fps">FPS</label>
        <input id="fps" type="number" min="1" max="60" value="24">
      </div>
      <div>
        <label for="aspect">Aspect</label>
        <select id="aspect">
          <option value="square">Square 1080√ó1080</option>
          <option value="landscape">Landscape 1920√ó1080</option>
          <option value="vertical">Vertical 1080√ó1920</option>
        </select>
      </div>
      <div style="grid-column: span 4; display:flex; align-items:end; gap:10px;">
        <button id="gen" type="button">üé¨ Generate timelapse</button>
        <div id="encmsg" class="muted">Encoder idle</div>
      </div>
    </div>
    
    <div class="row" style="align-items:center">
      <div style="grid-column: span 6;">
        <div id="bar" style="height:8px;background:#eee;border-radius:6px;overflow:hidden;">
          <div id="barfill" style="height:100%;width:0%;background:linear-gradient(90deg,#0eb2ff,#67e8a3)"></div>
        </div>
      </div>
    </div>
    
    <div class="row" style="align-items:center">
      <div style="grid-column: span 6; display:flex; gap:10px; flex-wrap:wrap;">
        <a id="dl-mp4" class="btn" download="timelapse.mp4" style="display:none">‚¨áÔ∏è MP4</a>
        <a id="dl-webm" class="btn" download="timelapse.webm" style="display:none">‚¨áÔ∏è WebM</a>
      </div>
    </div>


    <div id="msg">Ready. Open DevTools ‚Üí Console for logs.</div>
  </div>

  <div id="thumbs"></div>
  
  <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.10/dist/ffmpeg.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/util@0.12.1/dist/util.min.js" crossorigin="anonymous"></script>


  <script>
    // --- Minimal helpers ---
    const lambdaBase = "https://kgbbmarmdgv53gdb47pls2v2oe0qotcs.lambda-url.eu-central-1.on.aws/cog/tiles/WebMercatorQuad";
    const thumbs = document.getElementById("thumbs");
    const msg = document.getElementById("msg");
    const encmsg = document.getElementById("encmsg");
    const barfill = document.getElementById("barfill");
    const dlMp4 = document.getElementById("dl-mp4");
    const dlWebm = document.getElementById("dl-webm");
    const DEBUG = true;
  
    // Canonical list of frames; render from this (sorted, de-duped)
    const frames = []; // [{ date, idx, z, url }]
  
    function byDate(a, b) { return a.date.localeCompare(b.date); }
    function setMsg(t){ msg.textContent = t; }
    function setEncMsg(t){ encmsg.textContent = t; }
    function setBar(pct){ barfill.style.width = Math.max(0, Math.min(100, pct)) + "%"; }
    function validDate(s){ return /^\d{8}$/.test(s); }
    function nice(d){ return `${d.slice(0,4)}-${d.slice(4,6)}-${d.slice(6)}`; }
  
    function renderThumbs() {
      thumbs.innerHTML = "";
      frames.sort(byDate).forEach((f, i) => {
        const wrap = document.createElement("div");
        wrap.className = "thumb";
  
        const btn = document.createElement("button");
        btn.className = "rm";
        btn.type = "button";
        btn.title = "Remove";
        btn.textContent = "√ó";
        btn.onclick = () => {
          frames.splice(i, 1);
          renderThumbs();
          setMsg("Removed thumbnail.");
        };
  
        const img = document.createElement("img");
        img.src = f.url;
  
        const cap = document.createElement("div");
        cap.className = "cap";
        cap.textContent = `${nice(f.date)} ‚Ä¢ ${f.idx.toUpperCase()} ‚Ä¢ z${f.z}`;
  
        wrap.append(btn, img, cap);
        thumbs.appendChild(wrap);
      });
    }
  
    function parseDs(ds){
      const p = (ds||"").split("-");
      return { country: p[0], tile: p[1], uid: p[2] };
    }
    function productSuffix(idx){
      if (idx === "rgb") return "_TCI.tif";
      if (idx === "ndvi") return "_NDVI.tif";
      if (idx === "irp" || idx === "fcir") return "_IRP.tif";
      return "_TCI.tif";
    }
    function tilesFor(country, tile, uid, date, idx){
      const P = `${tile}-${uid}-${date}`;
      const root = `${lambdaBase}/{z}/{x}/{y}@2x?url=s3://sentinel-s2dr3/${country}/${tile}/${P}`;
      const suffix = productSuffix(idx);
      return [`${root}/S2L2Ax10_${P}${suffix}`];
    }
  
    // lon/lat ‚Üí XYZ tile indices at zoom z
    function lonLatToTile(lon, lat, z) {
      const x = Math.floor(((lon + 180) / 360) * Math.pow(2, z));
      const y = Math.floor(
        ((1 - Math.log(Math.tan((lat * Math.PI) / 180) + 1 / Math.cos((lat * Math.PI) / 180)) / Math.PI) / 2) *
        Math.pow(2, z)
      );
      return { x, y };
    }
    // tile center lon/lat (inverse)
    function tileCenterLonLat(z, x, y){
      const n = Math.pow(2, z);
      const lon = (x + 0.5) / n * 360 - 180;
      const t = Math.PI - 2 * Math.PI * (y + 0.5) / n;
      const lat = (180 / Math.PI) * Math.atan(Math.sinh(t));
      return { lon, lat };
    }
  
    // Probe one date: try current zoom, optionally 12 then 10; resolve only once on first success
    function probeDate(ds, idx, date, lon, lat, zoom, allowFallback){
      const { country, tile, uid } = parseDs(ds);
      if (!country || !tile || !uid) {
        alert("ds must be COUNTRY-TILE-UID (e.g., MG-T38KMC-e0a95e3ea)");
        return Promise.resolve({ ok:false });
      }
      const tmpl = tilesFor(country, tile, uid, date, idx)[0];
      const z0 = Math.max(0, Math.round(zoom));
      const zList = allowFallback ? Array.from(new Set([z0, 12, 10])) : [z0];
  
      return new Promise((resolve) => {
        let failures = 0;
        let done = false; // guard: first success wins
  
        zList.forEach(zc => {
          const { x, y } = lonLatToTile(lon, lat, zc);
          const url = tmpl.replace("{z}", zc).replace("{x}", x).replace("{y}", y)
                        + (tmpl.includes("?") ? "&" : "?") + "_cb=" + Date.now();
  
          if (DEBUG) console.log(`[probe] ${date} ${idx}@z${zc} x=${x} y=${y} ‚Üí`, url);
  
          const img = new Image();
          img.crossOrigin = "anonymous";
          img.onload = () => {
            if (done) return;
            if (DEBUG) console.log("  ‚úÖ loaded");
            done = true;
            resolve({ ok:true, url, z: zc, x, y });
          };
          img.onerror = () => {
            if (DEBUG) console.warn("  ‚ùå failed");
            failures++;
            if (failures === zList.length && !done) resolve({ ok:false });
          };
          img.src = url;
        });
      });
    }
  
    // --- UI: Add date ---
    document.getElementById("add").addEventListener("click", async () => {
      const lon  = parseFloat(document.getElementById("lon").value);
      const lat  = parseFloat(document.getElementById("lat").value);
      const zoom = parseInt(document.getElementById("zoom").value, 10);
      const ds   = (document.getElementById("ds").value || "").trim();
      const typeUi = document.getElementById("type").value;
      const idx  = (typeUi === "RGB") ? "rgb" : (typeUi === "IRP") ? "irp" : "ndvi";
      const date = (document.getElementById("date").value || "").trim();
      const allowFallback = document.getElementById("fallback").checked;
      const lockCenter = document.getElementById("lockCenter").checked;
  
      // validations
      if (!ds)                     { alert("Missing output_id (ds)"); return; }
      if (!validDate(date))        { alert("Date must be YYYYMMDD"); return; }
      if (!Number.isFinite(lon) || !Number.isFinite(lat)) { alert("Bad lon/lat"); return; }
      if (!Number.isFinite(zoom))  { alert("Bad zoom"); return; }
  
      // de-dup by (date, idx)
      if (frames.some(f => f.date === date && f.idx === idx)) {
        alert(`Date ${date} (${idx.toUpperCase()}) is already added.`);
        return;
      }
  
      setMsg("Probing tiles‚Ä¶ (see Console)");
      const res = await probeDate(ds, idx, date, lon, lat, zoom, allowFallback);
      if (!res.ok) {
        setMsg(`No tiles for ${idx.toUpperCase()} on ${nice(date)} at z${zoom}${allowFallback ? " (no fallback worked)" : ""}.`);
        return;
      }
  
      // Lock inputs to the successful tile center (for reproducibility)
      if (lockCenter && Number.isFinite(res.z) && Number.isFinite(res.x) && Number.isFinite(res.y)) {
        const c = tileCenterLonLat(res.z, res.x, res.y);
        document.getElementById("lon").value = c.lon.toFixed(6);
        document.getElementById("lat").value = c.lat.toFixed(6);
        document.getElementById("zoom").value = String(res.z);
        setMsg(`Found tiles for ${nice(date)} ‚Äî z${res.z}. Locked lon/lat to tile center.`);
      } else {
        setMsg(`Found tiles for ${nice(date)} ‚Äî z${res.z}.`);
      }
  
      // Add to state and re-render (sorted)
      frames.push({ date, idx, z: res.z, url: res.url });
      renderThumbs();
    });
  
    // Clear all thumbnails + state
    document.getElementById("clear").addEventListener("click", () => {
      frames.length = 0;      // reset state
      renderThumbs();         // reflect in UI
      setMsg("Cleared all thumbnails.");
    });
  
    // ---------- ffmpeg wiring ----------
    const FFmpeg = window.FFmpeg;
    const FFmpegUtil = window.FFmpegUtil;
    const { fetchFile } = FFmpegUtil;
    
    let ffmpeg = null;
    async function getFF() {
      if (ffmpeg) return ffmpeg;
      if (!FFmpeg) {
        alert("FFmpeg not loaded. Check script tags or blockers.");
        throw new Error("FFmpeg missing");
      }
      ffmpeg = new FFmpeg();
      ffmpeg.on("log", ({ message }) => {
        if (message && /frame=|muxing overhead/i.test(message)) setEncMsg(message);
      });
      await ffmpeg.load();
      return ffmpeg;
    }

  
    function aspectToWxH(aspect) {
      if (aspect === "landscape") return { w: 1920, h: 1080 };
      if (aspect === "vertical")  return { w: 1080, h: 1920 };
      return { w: 1080, h: 1080 }; // square default
    }
  
    // Fetch all image bytes (as Uint8Array). Requires CORS from tile server.
    async function fetchImageBytes(url) {
      const r = await fetch(url, { mode: "cors" });
      if (!r.ok) throw new Error(`Fetch failed ${r.status}`);
      const b = await r.arrayBuffer();
      return new Uint8Array(b);
    }
  
    // Encode using ffmpeg: write images as frame%03d.jpg and scale/pad to target WxH
    async function encodeTimelapse(sortedFrames, fps, aspect) {
      const { w, h } = aspectToWxH(aspect);
      const ff = await getFF();
  
      // Prepare FS
      try { ff.FS("readdir", "/frames"); } catch { ff.FS("mkdir", "/frames"); }
      try { ff.FS("readdir", "/out"); }    catch { ff.FS("mkdir", "/out"); }
  
      setEncMsg("Downloading frames‚Ä¶");
      setBar(5);
  
      // Download & write frame files
      for (let i = 0; i < sortedFrames.length; i++) {
        const f = sortedFrames[i];
        const bytes = await fetchImageBytes(f.url);
        const name = `/frames/frame${String(i).padStart(3, "0")}.jpg`;
        ff.FS("writeFile", name, bytes);
        setBar(5 + Math.floor((i + 1) / sortedFrames.length * 35)); // up to 40%
      }
  
      // Try MP4 (H.264). Use scale to fit within and pad to exact WxH (letterbox).
      // pad color: black (0,0,0). You can change to hex by pre-rendering, but ffmpeg needs numeric.
      setEncMsg("Encoding MP4‚Ä¶");
      let mp4Data = null, webmData = null;
  
      // Filter chain: scale to fit, then pad to exact WxH
      const vf = `scale=w='min(${w},iw*min(${w}/iw\\,${h}/ih))':h='min(${h},ih*min(${w}/iw\\,${h}/ih))',pad=${w}:${h}:(ow-iw)/2:(oh-ih)/2:black`;
  
      try {
        await ff.run(
          "-framerate", String(fps),
          "-i", "/frames/frame%03d.jpg",
          "-vf", vf,
          "-c:v", "libx264",
          "-pix_fmt", "yuv420p",
          "-movflags", "+faststart",
          "/out/timelapse.mp4"
        );
        mp4Data = ff.FS("readFile", "/out/timelapse.mp4");
      } catch (e) {
        console.warn("MP4 encode failed, falling back to WebM.", e);
      }
      setBar(85);
  
      if (!mp4Data) {
        setEncMsg("Encoding WebM fallback‚Ä¶");
        await ff.run(
          "-framerate", String(fps),
          "-i", "/frames/frame%03d.jpg",
          "-vf", vf,
          "-c:v", "libvpx-vp9",
          "-b:v", "2M",
          "/out/timelapse.webm"
        );
        webmData = ff.FS("readFile", "/out/timelapse.webm");
      }
      setBar(100);
  
      return { mp4Data, webmData };
    }
  
    // --- UI: Generate timelapse ---
    document.getElementById("gen").addEventListener("click", async () => {
      if (frames.length === 0) { alert("Add at least one date first."); return; }
      const fps = Math.max(1, Math.min(60, parseInt(document.getElementById("fps").value || "24", 10)));
      const aspect = document.getElementById("aspect").value;
  
      // Sort frames by date just in case
      const sorted = [...frames].sort(byDate);
  
      // Reset UI
      setEncMsg("Preparing encoder‚Ä¶");
      setBar(0);
      dlMp4.style.display = "none";
      dlWebm.style.display = "none";
  
      try {
        const { mp4Data, webmData } = await encodeTimelapse(sorted, fps, aspect);
  
        if (mp4Data && mp4Data.length) {
          const blob = new Blob([mp4Data.buffer], { type: "video/mp4" });
          dlMp4.href = URL.createObjectURL(blob);
          dlMp4.style.display = "inline-block";
          setEncMsg("Done! MP4 ready üéâ");
        } else if (webmData && webmData.length) {
          const blob = new Blob([webmData.buffer], { type: "video/webm" });
          dlWebm.href = URL.createObjectURL(blob);
          dlWebm.style.display = "inline-block";
          setEncMsg("MP4 not available ‚Äî WebM provided ‚úÖ");
        } else {
          setEncMsg("Encoding failed.");
        }
      } catch (e) {
        console.error(e);
        setEncMsg("Encoding error. See console.");
      }
    });
</script>


</body>
</html>
